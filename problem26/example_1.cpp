#include <iostream>
#include <fstream>
#include <algorithm>

// главный метод программы
int main() {
    // открываем файл
    std::ifstream myfile;
    // бинарник собирается в отдельной папке, поэтому относительный путь такой
    // можно вместо этого закинуть файл куда-нибудь на диск и указать полный путь
    myfile.open("../problem26/26.txt");

    // читаем объём хранилища
    int s;
    myfile >> s;
    // читаем кол-во файлов
    int n;
    myfile >> n;

    // создаём массив размеров файла
    int arr[n];
    // читаем размеры
    for (int i = 0; i < n; i++) {
        myfile >> arr[i];
    }
    // сортируем размеры по возрастанию
    std::sort(arr, arr + n);

    // сумма файлов
    int sum = 0;
    // индекс файла максимального размера
    int posMax = 0;

    // перебираем упорядоченные размеры файлов
    for (int i = 0; i < n; i++) {
        // если добавление
        if (sum + arr[i] <= s) {
            // прибавляем к сумме
            sum += arr[i];
            // т.к. мы перебираем размеры файлов в порядке возрастания,
            // то в переменной maxSize сохранится самый большой размер
            posMax = i;
        } else
            break;
    }

    // сохраняем максимальную сумму
    int max = sum;
    // максимальный размер сохраняемого файла
    int maxSize = arr[posMax];

    // перебираем все возможные пары элементов массива
    // первый элемент - один из индексов файлов, взятых для сохранения
    // их индексы находятся в диапазоне [0, posMax]
    for (int i = 0; i <= posMax; i++) {
        // второй элемент - один из индексов файлов, не взятых для сохранения
        // их индексы находятся в диапазоне [posMax+1, n)
        for (int j = posMax + 1; j < n; j++) {
            // находим сумму, которая бы получилась, если бы мы не сохранили файл, перебираемый
            // первым циклом и сохранили файл, перебираемый вторым
            int nSum = sum - arr[i] + arr[j];
            // если новая сумма не превышает заданный размер и
            // при этом больше найденной
            if (nSum <= s && nSum >= max) {
                // сохраняем её в качестве найденной
                max = nSum;
                // если новый файл по размеру больше максимального из сохранённых
                // нужно сравнивать именно с размером сохранённого
                // файла максимального размера, полученного на предыдущем этапе
                // ведь каждая проверка на замену файла происходит независимо
                if (arr[j] > arr[posMax])
                    // сохраняем размер
                    maxSize = arr[j];
            }
        }
    }

    // выводим максимальное количество
    std::cout << sum << " " << maxSize << std::endl;


    return 0;
}


